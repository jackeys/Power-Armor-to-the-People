{
  Power Armor Repair Requirements Patcher for Fallout 4
  by Skiesbleed
  
  This patcher is designed to go change the repair requirements to require perks depending on the type of power armor. It is designed for use when many power armor sets are installed to help differentiate them, and was made with the mod Power Armor to the People in mind.
  
  Requires: FO4Edit, MXPF
  Optional: Power Armor to the People and the many power armor sets it supports
  }

unit UserScript;
// Import MXPF functions
uses 'lib\mxpf';

const
  FormID_Armorer01Perk = $0004B254;
  FormID_Armorer02Perk = $0004B255;
  FormID_Armorer03Perk = $0004B256;
  FormID_Armorer04Perk = $001797EA;
  FormID_NuclearPhysicist01Perk = $001D246F;
  FormID_NuclearPhysicist02Perk = $001D2470;
  FormID_NuclearPhysicist03Perk = $001D2471;
  FormID_Science01Perk = $000264D9;
  FormID_Science02Perk = $000264DA;
  FormID_Science03Perk = $000264DB;

function PowerArmorRepairRequirements: TStringList;
begin
  Result := TStringList.Create;
  Result.Values['ma_PA_Raider'] = [FormID_Armorer01Perk];
  Result.Values['ma_PA_T45'] = [FormID_Armorer01Perk, FormID_Science01Perk];
  Result.Values['ma_PA_T51'] = [FormID_Armorer02Perk, FormID_Science01Perk];
  Result.Values['ma_PA_T60'] = [FormID_Armorer02Perk, FormID_Science02Perk];
  Result.Values['ma_PA_X01'] = [FormID_Armorer03Perk, FormID_Science02Perk, FormID_NuclearPhysicist02Perk];
end;

function Initialize: Integer;
var
  i: integer;
  createdObject: string;
  rec, armoRec: IInterface;
  perks: array of integer;
  repairRequirements: TStringList;
begin
  // set MXPF options and initialize it
  DefaultOptionsMXPF;
  InitializeMXPF;
  
  // select/create a new patch file that will be identified by its author field
  PatchFileByAuthor('Autogenerated PATTP Repair Patch');
  SetExclusions(mxHardcodedDatFiles);
  LoadRecords('COBJ');

  // If the constructible object is not used to repair power armor, remove it
  // it's important that the loop starts at MaxRecordIndex and goes down to 0
  // because we're removing records
  for i := MaxRecordIndex downto 0 do begin
    rec := GetRecord(i);
    armoRec := WinningOverride(LinksTo(ElementBySignature(rec, 'CNAM')));
    if not HasKeyword(armoRec, 'ArmorTypePower') then
      RemoveRecord(i);
  end;
  
  // then copy records to the patch file
  CopyRecordsToPatch;

  repairRequirements := PowerArmorRepairRequirements;
  
  // and set values on them
  for i := 0 to MaxPatchRecordIndex do begin
    rec := GetPatchRecord(i);
    createdObject := GetElementEditValues(rec, 'CNAM');
    AddMessage(Format('Copied %s, which creates %s', [Name(rec), createdObject]));

    //Find the repair requirements for this power armor piece
    perks := FindPerksForArmor(rec, repairRequirements);

    if perks = nil then begin
      AddMessage(Format('%s is an unknown type of power armor - skipping'), [Name(rec)]);
      continue;
    end;

    AddRepairConditions(rec, perks);
  end;
  
  // call PrintMXPFReport for a report on successes and failures
  PrintMXPFReport;
  
  // always call FinalizeMXPF when done
  FinalizeMXPF;
end;

function FindPerksForArmor(rec: IInterface, repairRequirements: TStringList): array of integer;
var
  i: integer;
begin
  Result := nil;
  for i := 0 to repairRequirements.Length do begin
    if HasKeyword(rec, repairRequirements.Names[i]) then begin
      Result := repairRequirements.ValueFromIndex[i];
      break;
    end;
  end;
end;

procedure AddRepairConditions(rec: IInterface, perks: array of integer);
var
item, conditions, condition, ctda, lastcondition, checkctda: IInterface;
i: integer;
begin
  conditions := ElementByName(rec, 'Conditions');
  if not Assigned(conditions) then begin
    conditions := Add(rec, 'Conditions', true);

    for i := 0 to (perks.Length - 1) do begin
      condition  := ElementAssign(conditions, i, nil, true);
      ctda       := ElementBySignature(ElementByIndex(conditions, i), 'CTDA');

      // Type is "Equal to"
      SetEditValue(ElementByName(ctda, 'Type'), '10000000');
      SetNativeValue(ElementByName(ctda, 'Comparison Value - Float'), 1.0);
      SetEditValue(ElementByName(ctda, 'Function'), 'HasPerk');
      SetEditValue(ElementByName(ctda, 'Perk'), Name(Perk(perks[i])));
    end;
  end
  else
    AddMessage(Format('WARNING: %s already has conditions, skipping', [Name(rec)]));
end;

function Perk(formID: integer): IInterface;
var
  fFallout4: IInterface;
begin
  fFallout4 := FileByName('Fallout4.esm');
  Result := RecordByFormID(fFallout4, (MasterCount(fFallout4) * $01000000 + formID), false);
end;

end.