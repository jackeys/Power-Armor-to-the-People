{
  Power Armor Repair Requirements Patcher for Fallout 4
  by Skiesbleed
  
  This patcher is designed to go change the repair requirements to require perks depending on the type of power armor. It is designed for use when many power armor sets are installed to help differentiate them, and was made with the mod Power Armor to the People in mind.
  
  Requires: FO4Edit, MXPF
  Optional: Power Armor to the People and the many power armor sets it supports
  }

unit UserScript;
// Import MXPF functions
uses 'lib\mxpf';

const
  FormID_Armorer01Perk = $0004B254;
  FormID_Armorer02Perk = $0004B255;
  FormID_Armorer03Perk = $0004B256;
  FormID_Armorer04Perk = $001797EA;
  FormID_NuclearPhysicist01Perk = $001D246F;
  FormID_NuclearPhysicist02Perk = $001D2470;
  FormID_NuclearPhysicist03Perk = $001D2471;
  FormID_Science01Perk = $000264D9;
  FormID_Science02Perk = $000264DA;
  FormID_Science03Perk = $000264DB;
  FormID_Science04Perk = $0016578F;
  UNKNOWN_POWER_ARMOR = -1;
  NO_REPAIR_REQUIREMENTS = 0;

function Initialize: Integer;
var
  i: integer;
  createdObject: string;
  rec, armoRec: IInterface;
  repairRequirements: TStringList;
begin
  // set MXPF options and initialize it
  DefaultOptionsMXPF;
  InitializeMXPF;
  
  // select/create a new patch file that will be identified by its author field
  PatchFileByAuthor('Autogenerated PATTP Repair Patch');
  SetExclusions(mxHardcodedDatFiles);
  LoadRecords('COBJ');

  // If the constructible object is not used to repair power armor, remove it
  // it's important that the loop starts at MaxRecordIndex and goes down to 0
  // because we're removing records
  for i := MaxRecordIndex downto 0 do begin
    rec := GetRecord(i);
    armoRec := WinningOverride(LinksTo(ElementBySignature(rec, 'CNAM')));
    if not HasKeyword(armoRec, 'ArmorTypePower') then
      RemoveRecord(i);
  end;
  
  // then copy records to the patch file
  CopyRecordsToPatch;

  // and set values on them
  for i := 0 to MaxPatchRecordIndex do begin
    rec := GetPatchRecord(i);
    armoRec := WinningOverride(LinksTo(ElementBySignature(rec, 'CNAM')));
    AddMessage(Format('Copied %s, which creates %s', [Name(rec), Name(armoRec)]));

    AddRepairConditions(rec, armoRec);
  end;
  
  // call PrintMXPFReport for a report on successes and failures
  PrintMXPFReport;

  // Remove anything we didn't end up change and clean the masters
  CleanMasters(mxPatchFile);
  
  // always call FinalizeMXPF when done
  FinalizeMXPF;
end;

procedure AddRepairConditions(rec: IInterface; armoRec: IInterface);
var
item, conditions, condition, ctda, lastcondition, checkctda: IInterface;
i: integer;
perks: array[0..2] of integer;
begin
  //Initialize the array to make sure there are no surprises
  perks[0] := UNKNOWN_POWER_ARMOR;
  perks[1] := NO_REPAIR_REQUIREMENTS;
  perks[2] := NO_REPAIR_REQUIREMENTS;

  //Find the repair requirements for this power armor piece

  //////////////////////////////
  // Non-Military Power Armor //
  //////////////////////////////

  if IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_Excavator') or IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_Construct') then begin
    perks[0] := NO_REPAIR_REQUIREMENTS;
  end;
  
  //////////////////////////////
  /// Improvised Power Armor ///
  //////////////////////////////

  if IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_Raider') then begin
    // Overboss doesn't have its own keyword, so we have to look at the name
    if ContainsText(Name(armoRec), 'Overboss') then perks[0] := FormID_Armorer03Perk
    else perks[0] := FormID_Armorer01Perk;
  end;
  if IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_Horse') then begin
    perks[0] := FormID_Armorer02Perk;
  end;
  
  //////////////////////////////
  //// Standard Power Armor ////
  //////////////////////////////

  if IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_T45') or IsPowerArmorSubtype(armoRec, 'ma_PA_T49') then begin
    perks[0] := FormID_Armorer01Perk;
    perks[1] := FormID_Science01Perk;
  end;
  if IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_T51') or IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_T52') or IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_Hellcat') or IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_CHS') then begin
    perks[0] := FormID_Armorer02Perk;
    perks[1] := FormID_Science01Perk;
  end;
  if IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_T60') or IsPowerArmorSubtype(armoRec, 'zzzM150IPAdn_PowerArmor_I01') or IsPowerArmorSubtype(armoRec, 'tumba_dn_PowerArmor_CPA') or IsPowerArmorSubtype(armoRec, 'ccSWKFO4001_dn_PowerArmor_CC1') then begin
    perks[0] := FormID_Armorer02Perk;
    perks[1] := FormID_Science02Perk;
  end;
  if IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_VaultTec') or IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_MidWest') then begin
    perks[0] := FormID_Armorer03Perk;
    perks[1] := FormID_Science02Perk;
  end;
  if IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_T65') or IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_Liberty') then begin
    perks[0] := FormID_Armorer03Perk;
    perks[1] := FormID_Science03Perk;
  end;
  if IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_Ultracite') then begin
    perks[0] := FormID_Armorer04Perk;
    perks[1] := FormID_Science04Perk;
  end;
  
  //////////////////////////////
  //// Advanced Power Armor ////
  //////////////////////////////

  // Unoctium's Enclave X-02
  if IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_X02') then begin
    perks[0] := FormID_Armorer02Perk;
    perks[1] := FormID_Science02Perk;
    perks[2] := FormID_NuclearPhysicist01Perk;
  end;
  // Creation Club X-02
  if IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_X01') or IsPowerArmorSubtype(armoRec, 'ccBGSFO4115_dn_PowerArmor_X02') or IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_Hellfire') or IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_X03') then begin
    perks[0] := FormID_Armorer03Perk;
    perks[1] := FormID_Science02Perk;
    perks[2] := FormID_NuclearPhysicist02Perk;
  end;
  // C1PH3RR's Enclave X-02 Black Devil
  if IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_CW_X02') then begin
    perks[0] := FormID_Armorer03Perk;
    perks[1] := FormID_Science03Perk;
    perks[2] := FormID_NuclearPhysicist02Perk;
  end;
  // The Chosen One version of Classic Advanced Power Armor uses a different naming keyword
  if IsPowerArmorSubtype(armoRec, 'ma_PA_CAPA') then begin
    perks[0] := FormID_Armorer04Perk;
    perks[1] := FormID_Science04Perk;
    perks[2] := FormID_NuclearPhysicist03Perk;
  end;

  // Check to make sure we should actually make changes

  if perks[0] = NO_REPAIR_REQUIREMENTS then begin
    AddMessage(Format('No changes required for %s - skipping', [Name(rec)]));
    Remove(rec);
    exit;
  end;

  if perks[0] = UNKNOWN_POWER_ARMOR then begin
    AddMessage(Format('%s is an unknown type of power armor - skipping', [Name(rec)]));
    Remove(rec);
    exit;
  end;

  // Time to add the conditions

  conditions := ElementByName(rec, 'Conditions');
  if Assigned(conditions) then begin
    AddMessage(Format('WARNING: %s already has conditions - skipping', [Name(rec)]));
    Remove(rec);
    exit;
  end;

  // The first condition is special and has to be done differently
  conditions := Add(rec, 'Conditions', true);
  ctda       := ElementByPath(rec, 'Conditions\Condition\CTDA');

  // Type is "Equal to"
  SetEditValue(ElementByName(ctda, 'Type'), '10000000');
  SetNativeValue(ElementByName(ctda, 'Comparison Value - Float'), 1.0);
  SetEditValue(ElementByName(ctda, 'Function'), 'HasPerk');
  SetEditValue(ElementByName(ctda, 'Perk'), Name(Perk(perks[i])));

  for i := 1 to (Length(perks) - 1) do begin
    if perks[i] = 0 then break;

    condition  := ElementAssign(conditions, i, nil, true);
    ctda       := ElementBySignature(ElementByIndex(conditions, i), 'CTDA');

    // Type is "Equal to"
    SetEditValue(ElementByName(ctda, 'Type'), '10000000');
    SetNativeValue(ElementByName(ctda, 'Comparison Value - Float'), 1.0);
    SetEditValue(ElementByName(ctda, 'Function'), 'HasPerk');
    SetEditValue(ElementByName(ctda, 'Perk'), Name(Perk(perks[i])));
  end;
end;

function IsPowerArmorSubtype(rec: IInterface; keyword: string): boolean;
begin
  Result := false;

  if HasKeyword(rec, keyword) then begin
    AddMessage(Format('%s has the keyword %s', [Name(rec), keyword]));
    Result := true;
  end;
end;

function Perk(formID: integer): IInterface;
var
  fFallout4: IInterface;
begin
  fFallout4 := FileByName('Fallout4.esm');
  Result := RecordByFormID(fFallout4, (MasterCount(fFallout4) * $01000000 + formID), false);
end;

end.