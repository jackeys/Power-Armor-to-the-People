{
  Power Armor Repair Requirements Patcher for Fallout 4
  by Skiesbleed
  
  This patcher is designed to go change the repair requirements to require perks depending on the type of power armor. It is designed for use when many power armor sets are installed to help differentiate them, and was made with the mod Power Armor to the People in mind.
  
  Requires: FO4Edit, MXPF
  Optional: Power Armor to the People and the many power armor sets it supports
  }

unit UserScript;
// Import MXPF functions
uses 'lib\mxpf';

// Perks come from the main game file, proxy items come from PARTS_VisiblePerkRequirements
// Add the constants here, and then update GetProxyItemEditorIdForPerk to contain the mapping
const
  ProxyItemPluginFilename = 'PARTS_VisiblePerkRequirements.esp';

  FormID_Armorer01Perk = $0004B254;
  EditorID_Armorer01ProxyItem = 'PARTS_misc_perkproxy_Armorer01';

  FormID_Armorer02Perk = $0004B255;
  EditorID_Armorer02ProxyItem = 'PARTS_misc_perkproxy_Armorer02';

  FormID_Armorer03Perk = $0004B256;
  EditorID_Armorer03ProxyItem = 'PARTS_misc_perkproxy_Armorer03';

  FormID_Armorer04Perk = $001797EA;
  EditorID_Armorer04ProxyItem = 'PARTS_misc_perkproxy_Armorer04';

  FormID_NuclearPhysicist01Perk = $001D246F;
  EditorID_NuclearPhysicist01ProxyItem = 'PARTS_misc_perkproxy_NuclearPhysicist01';

  FormID_NuclearPhysicist02Perk = $001D2470;
  EditorID_NuclearPhysicist02ProxyItem = 'PARTS_misc_perkproxy_NuclearPhysicist02';

  FormID_NuclearPhysicist03Perk = $001D2471;
  EditorID_NuclearPhysicist03ProxyItem = 'PARTS_misc_perkproxy_NuclearPhysicist03';

  FormID_Science01Perk = $000264D9;
  EditorID_Science01ProxyItem = 'PARTS_misc_perkproxy_Science01';

  FormID_Science02Perk = $000264DA;
  EditorID_Science02ProxyItem = 'PARTS_misc_perkproxy_Science02';

  FormID_Science03Perk = $000264DB;
  EditorID_Science03ProxyItem = 'PARTS_misc_perkproxy_Science03';

  FormID_Science04Perk = $0016578F;
  EditorID_Science04ProxyItem = 'PARTS_misc_perkproxy_Science04';

  FormID_GlobalZero = $00022B43;
  UNKNOWN_POWER_ARMOR = -1;
  NO_REPAIR_REQUIREMENTS = 0;
  bVerboseLogging = false;

var
  bOverwriteConditions, bRemoveConstruction, bReset, bUserCancelled: boolean;

function GetProxyItemEditorIdForPerk(perkFormId: Integer): string;
begin
  if perkFormId = FormID_Armorer01Perk then Result := EditorID_Armorer01ProxyItem
  else if perkFormId = FormID_Armorer02Perk then Result := EditorID_Armorer02ProxyItem
  else if perkFormId = FormID_Armorer03Perk then Result := EditorID_Armorer03ProxyItem
  else if perkFormId = FormID_Armorer04Perk then Result := EditorID_Armorer04ProxyItem

  else if perkFormId = FormID_NuclearPhysicist01Perk then Result := EditorID_NuclearPhysicist01ProxyItem
  else if perkFormId = FormID_NuclearPhysicist02Perk then Result := EditorID_NuclearPhysicist02ProxyItem
  else if perkFormId = FormID_NuclearPhysicist03Perk then Result := EditorID_NuclearPhysicist03ProxyItem
  
  else if perkFormId = FormID_Science01Perk then Result := EditorID_Science01ProxyItem
  else if perkFormId = FormID_Science02Perk then Result := EditorID_Science02ProxyItem
  else if perkFormId = FormID_Science03Perk then Result := EditorID_Science03ProxyItem
  else if perkFormId = FormID_Science04Perk then Result := EditorID_Science04ProxyItem
  
  else Result := ''
end;

function Initialize: Integer;
var
  i: integer;
  sFiles: string;
  rec, armoRec: IInterface;
  repairRequirements: TStringList;
begin
  // set MXPF options and initialize it
  DefaultOptionsMXPF;
  InitializeMXPF;

  ShowOptionsForm;

  if bUserCancelled then begin 
    AddMessage('Patching cancelled');
    exit;
  end;

  SetExclusions(mxHardcodedDatFiles);
  PatchFileByAuthor('Autogenerated PATTP Repair Patch');
  
  if bReset then RemoveNode(GroupBySignature(mxPatchFile, 'COBJ'));

  LoadRecords('COBJ');

  // If the constructible object is not used to repair power armor, remove it
  // it's important that the loop starts at MaxRecordIndex and goes down to 0
  // because we're removing records
  for i := MaxRecordIndex downto 0 do begin
    rec := GetRecord(i);
    armoRec := WinningOverride(LinksTo(ElementBySignature(rec, 'CNAM')));
    if not HasKeyword(armoRec, 'ArmorTypePower') then
      RemoveRecord(i);
  end;
  
  // then copy records to the patch file
  CopyRecordsToPatch;

  // and set values on them
  for i := 0 to MaxPatchRecordIndex do begin
    rec := GetPatchRecord(i);
    armoRec := WinningOverride(LinksTo(ElementBySignature(rec, 'CNAM')));

    if bVerboseLogging then AddMessage(Format('Patching %s, which creates %s', [Name(rec), Name(armoRec)]));

    AddRepairConditions(rec, armoRec);
  end;
  
  // call PrintMXPFReport for a report on successes and failures
  PrintMXPFReport;

  // Remove anything we didn't end up change and clean the masters
  CleanMasters(mxPatchFile);
  
  // always call FinalizeMXPF when done
  FinalizeMXPF;
end;

procedure AddRepairConditions(rec: IInterface; armoRec: IInterface);
var
item, conditions, condition, ctda, lastcondition, checkctda, workbench, components, perkProxyComponent, perkProxyItem: IInterface;
i, perkProxyFormId: integer;
perks: array[0..2] of integer;
begin
  //Initialize the array to make sure there are no surprises
  perks[0] := UNKNOWN_POWER_ARMOR;
  perks[1] := NO_REPAIR_REQUIREMENTS;
  perks[2] := NO_REPAIR_REQUIREMENTS;

  //Find the repair requirements for this power armor piece

  //////////////////////////////
  //// Civilian Power Armor ////
  //////////////////////////////

  if IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_Excavator') or IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_Construct') or IsPowerArmorSubtype(armoRec, 'ma_PA_SubRedux') or IsPowerArmorSubtype(armoRec, 'SKI_MAKO_MA_DivingPa') then begin
    perks[0] := NO_REPAIR_REQUIREMENTS;
  end;
  
  //////////////////////////////
  /// Improvised Power Armor ///
  //////////////////////////////

  if IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_Raider') or IsPowerArmorSubtype(armoRec, '000IndustrialistPA') then begin
    // Overboss and Trapper power armor don't have their own keywords, so we have to look at the name
    if ContainsText(Name(armoRec), 'Overboss') then perks[0] := FormID_Armorer03Perk
    else if ContainsText(Name(armoRec), 'Trapper') then perks[0] := FormID_Armorer02Perk
    else perks[0] := FormID_Armorer01Perk;
  end;
  if IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_Horse') or IsPowerArmorSubtype(armoRec, 'tumba_INNRs_PowerArmor_Cagebreaker') then begin
    perks[0] := FormID_Armorer02Perk;
  end;
  // Hermit doesn't have a unique keyword, so we have to check the name, too
  if IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_X01') and ContainsText(Name(armoRec), 'Hermit') then begin
    perks[0] := FormID_Armorer03Perk;
  end;
  
  //////////////////////////////
  //// Standard Power Armor ////
  //////////////////////////////

  if IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_T45') or IsPowerArmorSubtype(armoRec, 'ma_PA_T49') or IsPowerArmorSubtype(armoRec, 'TNPA_ma_PA_Atomite') then begin
    perks[0] := FormID_Armorer01Perk;
    perks[1] := FormID_Science01Perk;
  end;
  if IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_T51') or IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_T52') or IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_Hellcat') or IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_CHS') or IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_T47R') or IsPowerArmorSubtype(armoRec, 'eXo_dn_PowerArmor_BoS') then begin
    perks[0] := FormID_Armorer02Perk;
    perks[1] := FormID_Science01Perk;
  end;
  if IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_T60') or IsPowerArmorSubtype(armoRec, 'zzzM150IPAdn_PowerArmor_I01') or IsPowerArmorSubtype(armoRec, 'InstitutePAm150dn_PowerArmor') or IsPowerArmorSubtype(armoRec, 'tumba_dn_PowerArmor_CPA') or IsPowerArmorSubtype(armoRec, 'ccSWKFO4001_dn_PowerArmor_CC1') or IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_SELPA') or IsPowerArmorSubtype(armoRec, 'dn_T53_PowerArmor_CPA') or IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_T47R_QS') or IsPowerArmorSubtype(armoRec, 'DN_Bobcat') or IsPowerArmorSubtype(armoRec, 'Tumba_DN_GunnerPA_Bobcat') or IsPowerArmorSubtype(armoRec, 'DN_Lynx') or IsPowerArmorSubtype(armoRec, 'Tumba_DN_GunnerPA_Lynx') then begin
    perks[0] := FormID_Armorer02Perk;
    perks[1] := FormID_Science02Perk;
  end;
  if IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_VaultTec') or IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_MidWest') or IsPowerArmorSubtype(armoRec, 'tumba_ma_PA_Tank') or IsPowerArmorSubtype(armoRec, 'ma_PA_TES51') or IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_Soviet') or IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_MWR') then begin
    perks[0] := FormID_Armorer03Perk;
    perks[1] := FormID_Science02Perk;
  end;
  if IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_T65') or IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_Liberty') or IsPowerArmorSubtype(armoRec, 'tumba_dn_PowerArmor_Synth') then begin
    perks[0] := FormID_Armorer03Perk;
    perks[1] := FormID_Science03Perk;
  end;
  if IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_Ultracite') then begin
    perks[0] := FormID_Armorer04Perk;
    perks[1] := FormID_Science04Perk;
  end;
  
  //////////////////////////////
  //// Advanced Power Armor ////
  //////////////////////////////

  // Unoctium's Enclave X-02
  if IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_X02') then begin
    perks[0] := FormID_Armorer02Perk;
    perks[1] := FormID_Science02Perk;
    perks[2] := FormID_NuclearPhysicist01Perk;
  end;
  // Creation Club X-02, both Hellfire power armors, Enclave power armor
  if IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_X01') or IsPowerArmorSubtype(armoRec, 'ccBGSFO4115_dn_PowerArmor_X02') or IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_Hellfire') or IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_X03') or IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_Enclave') or IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_Equalizer') then begin
    perks[0] := FormID_Armorer03Perk;
    perks[1] := FormID_Science02Perk;
    perks[2] := FormID_NuclearPhysicist02Perk;
  end;
  // C1PH3RR's Enclave X-02 Black Devil
  if IsPowerArmorSubtype(armoRec, 'dn_PowerArmor_CW_X02') then begin
    perks[0] := FormID_Armorer03Perk;
    perks[1] := FormID_Science03Perk;
    perks[2] := FormID_NuclearPhysicist02Perk;
  end;
  // The Chosen One version of Classic Advanced Power Armor uses a different naming keyword
  if IsPowerArmorSubtype(armoRec, 'ma_PA_CAPA') then begin
    perks[0] := FormID_Armorer04Perk;
    perks[1] := FormID_Science04Perk;
    perks[2] := FormID_NuclearPhysicist03Perk;
  end;

  // We won't patch anything we don't know about

  if perks[0] = UNKNOWN_POWER_ARMOR then begin
    AddMessage(Format('%s is an unknown type of power armor - skipping', [Name(rec)]));
    Remove(rec);
    exit;
  end;

  // If this has a workbench associated with it, it's a recipe for constructing power armor, not repairing it
  // We want to check now, because even if no conditions need to be added for repair, we still want to disable recipes
  workbench := ElementBySignature(rec, 'BNAM');
  if Assigned(workbench) and bRemoveConstruction then begin
    AddMessage(Format('%s is a recipe for constructing power armor - disabling', [Name(rec)]));

    // Liberty Power Armor and SE-01 use the same constructible object for repairs and construction, so we have to remove the workbench and let patching continue
    if ContainsText(Name(rec), 'co_Armor_Power_Liberty') or ContainsText(Name(rec), 'co_Armor_Power_SELPA') then begin
      Remove(workbench);
      // We explicitly do not want to exit here - we still need to add perks, since this gets used for repair
    end
    else begin
      conditions := Add(rec, 'Conditions', true);
      ctda       := ElementByPath(rec, 'Conditions\Condition\CTDA');

      // We can disable the recipe by requiring that a global variable that is always set to 0 is equal to 1
      SetEditValue(ElementByName(ctda, 'Type'), '10000000');
      SetNativeValue(ElementByName(ctda, 'Comparison Value - Float'), 1.0);
      SetEditValue(ElementByName(ctda, 'Function'), 'GetGlobalValue');
      SetEditValue(ElementByName(ctda, 'Global'), MainFileFormName(FormID_GlobalZero));
      exit;
    end;
  end;

  if perks[0] = NO_REPAIR_REQUIREMENTS then begin
    if bVerboseLogging then AddMessage(Format('No conditions required for %s - skipping', [Name(rec)]));
    Remove(rec);
    exit;
  end;

  // Unless configured to, we won't override any existing conditions

  conditions := ElementByName(rec, 'Conditions');
  if Assigned(conditions) then begin
    if bOverwriteConditions then begin
      AddMessage(Format('%s has existing conditions - overwriting', [Name(rec)]));
      Remove(conditions);
    end
    else begin
      AddMessage(Format('%s already has conditions - skipping', [Name(rec)]));
      Remove(rec);
      exit;
    end;
  end;

  // The first condition is special and has to be done differently
  conditions := Add(rec, 'Conditions', true);
  ctda       := ElementByPath(rec, 'Conditions\Condition\CTDA');

  // Type is "Equal to"
  SetEditValue(ElementByName(ctda, 'Type'), '10000000');
  SetNativeValue(ElementByName(ctda, 'Comparison Value - Float'), 1.0);
  SetEditValue(ElementByName(ctda, 'Function'), 'HasPerk');
  SetEditValue(ElementByName(ctda, 'Perk'), MainFileFormName(perks[i]));

  AddPerkProxyRequirement(rec, perks[i]);

  for i := 1 to (Length(perks) - 1) do begin
    if perks[i] = NO_REPAIR_REQUIREMENTS then break;

    condition  := ElementAssign(conditions, i, nil, false);
    ctda       := ElementBySignature(ElementByIndex(conditions, i), 'CTDA');

    // Type is "Equal to"
    SetEditValue(ElementByName(ctda, 'Type'), '10000000');
    SetNativeValue(ElementByName(ctda, 'Comparison Value - Float'), 1.0);
    SetEditValue(ElementByName(ctda, 'Function'), 'HasPerk');
    SetEditValue(ElementByName(ctda, 'Perk'), MainFileFormName(perks[i]));

    AddPerkProxyRequirement(rec, perks[i]);
  end;
end;

procedure AddPerkProxyRequirement(rec: IInterface; perkFormId: integer);
var
components, perkProxyComponent, perkProxyItem: IInterface;
perkProxyEditorId: string;
begin
  if not assigned(FileByName(ProxyItemPluginFilename)) then exit;
  
  perkProxyEditorId := GetProxyItemEditorIdForPerk(perkFormId);
  if perkProxyEditorId = '' then exit;

  perkProxyItem := VisualPerkFormName(perkProxyEditorId);
  if not assigned(perkProxyItem) then exit;

  components := ElementByName(rec, 'FVPA - Components');
  perkProxyComponent := ElementAssign(components, HighInteger, nil, false);
  SetEditValue(ElementByName(perkProxyComponent, 'Component'), perkProxyItem);
  SetEditValue(ElementByName(perkProxyComponent, 'Count'), 1);
end;

function IsPowerArmorSubtype(rec: IInterface; keyword: string): boolean;
begin
  Result := false;

  if HasKeyword(rec, keyword) then begin
    if bVerboseLogging then AddMessage(Format('%s has the keyword %s', [Name(rec), keyword]));
    Result := true;
  end;
end;

function MainFileFormName(formID: integer): IInterface;
var
  fFallout4: IInterface;
begin
  fFallout4 := FileByName('Fallout4.esm');
  Result := Name(RecordByFormID(fFallout4, formID, false));
end;

function VisualPerkFormName(editorId: string): IInterface;
var
  fVisiblePerkPlugin: IInterface;
begin
  // Doing this by form ID didn't work with larger load orders, so use the editor ID instead
  AddMasterIfMissing(mxPatchFile, ProxyItemPluginFilename);
  fVisiblePerkPlugin := FileByName(ProxyItemPluginFilename);  
  Result := Name(MainRecordByEditorID(GroupBySignature(fVisiblePerkPlugin, 'MISC'), editorId));
end;

procedure ShowOptionsForm;
var
  frm: TForm;
  cbOverwriteConditions, cbRemoveConstruction: TCheckBox;
  btnNewPatch, btnAmend, btnCancel: TButton;
  i, iValueInt: integer;
begin
  frm := TForm.Create(nil);
  try
    frm.BorderStyle := bsDialog;
    frm.Height := 140;
    frm.Width := 280;
    frm.Position := poScreenCenter;
    frm.Caption := 'Power Armor Repair Requirement Patcher';

    cbOverwriteConditions := ConstructCheckbox(frm, frm, 20, 50, 300, 'Overwrite existing repair conditions', cbChecked, '');
    cbOverwriteConditions.Checked := false;
    cbOverwriteConditions.ShowHint := true;
    cbOverwriteConditions.Hint := 'If a condition is already found for repairing a piece of power armor, should those conditions be overwritten by this patcher?';

    cbRemoveConstruction := ConstructCheckbox(frm, frm, cbOverwriteConditions.Top + 20, 50, 300, 'Remove Power Armor Recipes', cbChecked, '');	 
    cbRemoveConstruction.Checked := false;
    cbRemoveConstruction.ShowHint := true;
    cbRemoveConstruction.Hint := 'If a mod allows power armor to be built at a chem lab or other workbench, this will make those recipes unavailable';
    
    btnNewPatch := TButton.Create(frm);
    btnNewPatch.Parent := frm;
    btnNewPatch.Left := frm.Width div 3 - btnNewPatch.Width -3;
    btnNewPatch.Top := cbRemoveConstruction.Top + 40;
    btnNewPatch.Caption := 'New Patch';
    btnNewPatch.ModalResult := mrYes;
    btnNewPatch.ShowHint := true;
    btnNewPatch.Hint := 'Clear previous patched records and re-run the script completely';
  
    btnAmend := TButton.Create(frm);
    btnAmend.Parent := frm;
    btnAmend.Left := btnNewPatch.Left + btnNewPatch.Width + 9;
    btnAmend.Top := btnNewPatch.Top;
    btnAmend.Caption := 'Amend';
    btnAmend.ModalResult := mrNo;
    btnAmend.ShowHint := true;
    btnAmend.Hint := 'Add new entries without clearing previously patched records';
    
    btnCancel := TButton.Create(frm);
    btnCancel.Parent := frm;
    btnCancel.Left := btnAmend.Left + btnAmend.Width + 9;
    btnCancel.Top := btnNewPatch.Top;
    btnCancel.Caption := 'Cancel';
    btnCancel.ModalResult := mrCancel;
  
    i := frm.ShowModal;
    bUserCancelled := i = mrCancel;
    bReset := i = mrYes;
    if not bUserCancelled then begin
      bOverwriteConditions := cbOverwriteConditions.Checked;
      bRemoveConstruction := cbRemoveConstruction.Checked;
    end;
  finally
    frm.Free;
  end;
end;

end.